call fill_array		; заполнение массива
call counting_sort	; сортировка массива методом подсчёта
call sum_of_third		; подсчёт суммы элементов, индексы которых кратны трём (ответ в регистре B)
call find_min_max		; поиск минимального и максимального элементов
hlt				; конец программы


fill_array:		; функция заполнения массива
lxi h, 00A0h	; адрес начала массива в ОЗУ (в регистрах HL)
mvi m, 4	; элемент 10
inx h
mvi m, 2	; элемент 9	
inx h	
mvi m, 2	; элемент 8
inx h	
mvi m, 5	; элемент 7
inx h	
mvi m, 3	; элемент 6
inx h	
mvi m, 1	; элемент 5
inx h
mvi m, 1	; элемент 4
inx h	
mvi m, 0	; элемент 3
inx h	
mvi m, 3	; элемент 2
inx h	
mvi m, 5	; элемент 1
inx h					
ret


counting_sort:	; функция сортировки массива методом подсчёта	
mvi b, 5		; подсчитываемый элемент массива (в регистре B)		

iteration:			
lxi h, 00A0h	; адрес начала массива в ОЗУ (в рестрах HL)		 
mvi c, 10		; счётчик количества элементов массива (в регистре C)
mvi d, 0		; счётчик подсчитанных элементов B (в регистре D)

loop:
mov a, m		; загрузка в акк-р A значения элемента массива
cmp b			; сравнение элемента с подсчитываемым значением B
jnz not_equal	; проверка регистра Z	
inr d			; если регистр Z=1 (A=B, найден искомый элемент) увеличиваем счётчик D
not_equal:		; иначе его не трогаем
inx h			; переход к следующей ячейке массива
dcr c			; уменьшаем счётчик числа элементов массива C
jnz loop		; если C!=0 (массив не окончен) обрабатываем следующую ячейку

push d		; загрузка в стек количества подсчитанных элементов
dcr b			; установка нового подсчитываемого элемента (B-1)
jm stop		; если B<0 переходим к этапу заполнения массива
jmp iteration	; если B>=0 начинаем подсчёт нового элемента B

stop:
lxi h, 00A0h	; адрес начала массива в ОЗУ (в рестрах HL)		 
mvi b, 0		; записываемое в массив значение (регистр B)
mvi c, 6		; счётчик числа различных значений массива, k (регистр C)

fill_sorted:	; заполнение массива элементами в отсортированном порядке
pop d			; загрузка из стека количества элементов B в массиве (регистр D)

enter_el:		; запись в массив значения B (D-раз)
mov m, b		; запись нового значения в отсортированный массив
inx h			; переход к следующей ячейке массива
dcr d			; узнать сколько элементов B осталось записать
jnz enter_el	; если осталось для записи >0 элементов продолжить запись

inr b			; новое записываемое значение (B+1)
dcr c			; уменьшаем число значений, которые осталось записать
jnz fill_sorted	; если записаны не все значения, продолжить запись

ret			; конец сортировки


sum_of_third:	; подсчёт суммы элементов, индексы которых кратны трём (ответ в регистре B)
lxi h, 009Fh	; одна ячейка до начала массива в ОЗУ (в регистрах HL)
mvi c, 0		; счётчик количества элементов массива (в регистре C)
mvi b, 0		; сумма элементов кратных трём (в регистре B)

sum_loop:
inx h			; перейти на три ячейки вперёд
inx h			
inx h			
mov a, c		; увеличить счётчик C на 3 (через аккумулятор)
adi 3	
mov c, a
cpi 10		; сравнить значение аккумулятора с 10 (проверка конца массива)
jc less_or_eq	; проверка A<10
jz less_or_eq	; проверка A=10
ret			; если счётчик элементов массива A>10 - конец подсчёта (ответ в B)

less_or_eq:		
mov a, b		; прибавить значение ячейки к регистру для суммы B (через акк.)
add m
mov b, a
jmp sum_loop	; перейти ещё на три элемента вперёд


find_min_max:
lxi h, 00A0h	; одна ячейка до начала массива в ОЗУ (в регистрах HL)
mvi c, 10		; счётчик количества элементов массива (в регистре C)
mvi d, 0		; регистр для максимального элемента (D)
mov e, m		; регистр для минимального элемента (E)

find_max:		; сравнение с максимальным найденным элементом
mov a, m		; загрузка в акк-р значения ячейки массива
cmp d			; сравнение значения акк-ра со значением регистра D
jc find_min		; если A<=D ничего не менять
mov d, a		; иначе перезаписать D значением акк-ра

find_min:		; сравнение с минимальным найденным элементом
cmp e			; сравнение значения акк-ра со значением регистра E
jnc next_cell	; если A>D ничего не менять
mov e, a		; иначе перезаписать E значением акк-ра

next_cell:		
inx h			; переход к следующей ячейке массива в ОЗУ
dcr c			; уменьшение счётчика элементов массива
jnz find_max	; если счётчик не на нуле продолжить поиски
ret

