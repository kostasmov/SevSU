import numpy as np

class KNearestNeighbor(object):
    """ kNN классификатор с использованием L2 расстояния """
    def __init__(self):
        pass
    
    def train(self, X, y):  
        """
        Функция обучения классификатора. Для k-ближайших соседей это просто
        запоминание обучающих данных.

        Входы:
         - X: numpy массив формы (num_train, D), содержащий данные обучения.
           состоящий из  num_train выборок, каждая из которых имеет размерность D.
         - y: numpy  массив формы (N,), содержащий обучающие метки, где
              y[i] — метка X[i].
        """
        self.X_train = X
        self.y_train = y
    
    def predict(self, X, k=1, num_loops=0):
        """
         Предсказывает метки для тестовых данных.

         Входы:
         - X:  numpy массив формы (num_test, D), содержащий тестовые данные, состоящие
              из num_test выборок размером D.
         - k: количество ближайших соседей, голосующих за предсказанные метки.
         - num_loops: определяет, какую реализацию использовать для вычисления расстояний
           между обучающими примерами и тестовыми примерами.

         Возвращает:
         - y: numpy массив  формы (num_test,), содержащий предсказанные метки для
           тестовых примеров, где y[i] — предсказанная метка для тестового примера X[i].
        """
        if num_loops == 0:
            dists = self.compute_distances_no_loops(X)
        elif num_loops == 1:
            dists = self.compute_distances_one_loop(X)
        elif num_loops == 2:
            dists = self.compute_distances_two_loops(X)
        else:
            raise ValueError('Ошибочное значение %d для num_loops' % num_loops)

        return self.predict_labels(dists, k=k)

    def compute_distances_two_loops(self, X):
        """
        Вычисляет расстояние между каждым тестовым изображением из X и каждым обучающим
        изображением из self.X_train, используя вложенные циклы как по обучающим, так и по
        тестовым данным.

        Входы:
        - X: numpy массив формы (num_test, D), содержащий тестовые данные.

        Возращает:
        - dists: numpy array формы (num_test, num_train), содержащий  dists[i, j] -
          Евклидовы расстояния между i-м тестовым изображением j-м обучающим примером
        """
        num_test = X.shape[0]
        num_train = self.X_train.shape[0]
        dists = np.zeros((num_test, num_train))
        for i in range(num_test):
            for j in range(num_train):
                #####################################################################
                # ЗАДАНИЕ:                                                          #
                # Вычислить L2 расстояние между i-ым тестовым изображением и j-ым   #
                # обучающим изображением, сохранить результат в dists[i,j]. Вы не   #
                # должны использовать цикл по размерности самого изображения        #
                #####################################################################
         
                dists[i,j] = np.sqrt(np.sum(np.square(self.X_train[j,:] - X[i,:])))        
    
                #####################################################################
                #                       КОНЕЦ ВАШЕГО КОДА                           #
                #####################################################################
        return dists

    def compute_distances_one_loop(self, X):
        """
        Вычисляет расстояние между каждым тестовым примером данных их X и каждым обучающим примером
        из self.X_train, используя один цикл обработки тестовых данных.

        Ввод/вывод: то же, что и сompute_distances_two_loops.
        """
        num_test = X.shape[0]
        num_train = self.X_train.shape[0]
        dists = np.zeros((num_test, num_train))
        for i in range(num_test):
            #######################################################################
            # ЗАДАНИЕ:                                                            #
            # Вычислить расстояние L2 между i-ым тестовым изображением и всеми    #
            # обучающим изображениями, сохранить результат в dists[i,:].          #
            #######################################################################
            
            dists[i, :] = np.sqrt(np.sum(np.square(self.X_train - X[i, :]), axis=1))
            
            #######################################################################
            #                         КОНЕЦ ВАШЕГО КОДА                           #
            #######################################################################
        return dists

    def compute_distances_one_loopL1(self, X):
        """
        Вычисляет расстояние L1 между каждым тестовым примером данных их X и каждым обучающим примером
        из self.X_train, используя один цикл обработки тестовых данных.

        Ввод/вывод: то же, что и сompute_distances_two_loops.
        """
        num_test = X.shape[0]
        num_train = self.X_train.shape[0]
        dists = np.zeros((num_test, num_train))
        for i in range(num_test):
            #######################################################################
            # ЗАДАНИЕ:                                                            #
            # Вычислить расстояние L1 между i-ым тестовым изображением и всеми    #
            # обучающим изображениями, сохранить результат в dists[i,:].          #
            #######################################################################
            
            dists[i, :] = np.sum(np.abs(self.X_train - X[i, :]), axis=1)
            
            #######################################################################
            #                         КОНЕЦ ВАШЕГО КОДА                           #
            #######################################################################
        return dists

    def compute_distances_no_loops(self, X):
        """
        Вычисляет расстояние между каждым тестовым примером данных из X и каждым обучающим примером
        из self.X_train без явных циклов.

        Ввод/вывод: то же, что и сompute_distances_two_loops.
        """
        num_test = X.shape[0]
        num_train = self.X_train.shape[0]
        dists = np.zeros((num_test, num_train)) 
        #########################################################################
        # ЗАДАНИЕ:                                                              #
        # Вычислить расстояние L2 между всеми тестовыми изображениями и всеми   #
        # обучающим изображениями без использования циклов,сохранить результат  #
        # в dists.                                                              #
        #                                                                       #
        # Вы должны реализовать эту функцию, используя только базовые операции  #
        # с массивами; в частности, Вы не должны использовать функции из scipy  #  
        #                                                                       #
        # Совет: Попытайтесь сформулировать задачу вычисления L2 расстояния,    #
        # используя матричное умножение и 2 операции транслирования суммы       #
        # Воспользуйтесь формулой расстояния L2:                                #
        # DistOf [X_tr(j)-X(i)]=sqrt(X_tr(j)*X_tr(j)-2X_tr(j)*X(i)+X(i)*X(i))   #
        #########################################################################
    
        # воспользуемся формулой евкл. расстояния между изображениями-векторами j и i
        # sqrt(square(X_tr(j)-X(i)))=sqrt(X_tr(j)*X_tr(j)-2X_tr(j)*X(i)+X(i)*X(i))
        
        # вычисляем матрицу X_tr(j) * X(i)
        x1 = np.dot(X, self.X_train.T)                      # размеры (Nte x D)dot(D x Ntr)-->(Nte x Ntr)
        
        # вычисляем векторы суммы квадратов X_tr(j) * X_tr(j)
        x2 = np.sum(self.X_train * self.X_train, axis=1)    # размеры sum((Ntr x D)*(Ntr x D)-->(Ntr x D).axis=1)-->(Ntr,)
        
        # вычисляем векторы суммы квадратов X(i)*X(i)
        x3 = np.sum(X * X, axis=1) # размеры sum((Nte x D)*(Nte x D)-->(Nte x D).axis=1)-->(Nte,)
        
        # вычисляем X_tr(j) * X_tr(j) - 2X_tr(j) * X(i)
        # используем транслирование для x2           
        x4 = np.reshape(x2, (1, num_train)) - 2 * x1        # размеры (1,Ntr)-(Nte x Ntr)-->(Nte x Ntr)
        
        # вычисляем sqrt(X_tr(j) * X_tr(j) - 2X_tr(j) * X(i) + X(i) * X(i))
        #используем транслирование для x3
        dists = np.sqrt(x4 + np.reshape(x3, (num_test, 1))) # размеры (Nte х Ntr)+(Nte x 1)-->(Nte x Ntr)
        
        #########################################################################
        #                         КОНЕЦ ВАШЕГО КОДА                             #
        #########################################################################
        return dists


    def predict_labels(self, dists, k=1):
        """  
        Для заданной матрицы расстояний между тестовыми примерами данных и обучающими примерами
        предсказывает метку каждого тестового примера.

         Входы:
         - dists: numpy массив  формы (num_test, num_train), где dists[i, j]
           - расстояние между i-м тестовым примером и j-м обучающим примером.

         Возвращает:
         - y: numpy массив  формы (num_test), содержащий предсказанные метки для
           тестовых  примеров данных, где y[i] — предсказанная метка тестового примера X[i].
        """
        num_test = dists.shape[0]
        y_pred = np.zeros(num_test)
    
        # подсказка
        ind_arr = np.argsort(dists, axis=1) # сортируем матрицу dists в пределах строки и получаем массив упорядоченных индексов 
    
        for i in range(num_test):
            # Список длины k, в котором хранятся метки k ближайших соседей
            # к i-му тестовому примеру
            closest_y = []
            
            #########################################################################
            # ЗАДАНИЕ:                                                              #
            # Используя матрицу расстояний, найдите k ближайших соседей для i-го    #
            # тестового изображения, и , используя self.y_train, найдите метки этих #
            # соседей.                                                              #
            # Совет: Изучите функцию numpy.argsort                                  #
            #########################################################################
            
            closest_y = self.y_train[ind_arr[i, :k]] # выбираем из у_train k меток ближайших обуч. изображений  для i-го теста
        
            #########################################################################
            # ЗАДАНИЕ:                                                              #
            # Теперь, когда Вы нашли метки k ближайших соседей, Вам необходимо      #
            # найти наиболее часто встречаемую метку в списке меток closest_y.      #
            # Сохраните эту метку в у_pred[i].
            ######################################################################### 
            
            num_classes = 10                       # число классов
            count_label = np.zeros(num_classes)    # счетчики меток для каждого класса (счетчик голосов)
            
            for j in range(k):
                for l in range(num_classes):
                    if closest_y[j] == l:
                        count_label[l] += 1
            
            # выполняем поиск метки с максимальным числом голосов
            max = 0
            indmax = 0
            for l in range(num_classes):
                if count_label[l] >= max:
                    max = count_label[l]
                    indmax = l            # номер класса с максимальным числом голосв для i-го теста
            y_pred[i] = indmax
            
            #########################################################################
            #                           КОНЕЦ ВАШЕГО КОДА                           # 
            #########################################################################

        return y_pred

