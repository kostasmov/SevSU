from builtins import object
import numpy as np

from dlcv.layers import *
from dlcv.fast_layers import *
from dlcv.layer_utils import *


class ThreeLayerConvNet(object):
    """
    Трехслойная сверточная сеть со следующей архитектурой:

      conv - relu - 2x2 max pool - affine - relu - affine - softmax

    Сеть работает на мини-блоках данных, имеющих форму (N, C, H, W) и
    состоящих из N изображений, каждое  высотой H , шириной W и  C
    каналами.
    """

    def __init__(self, input_dim=(3, 32, 32), num_filters=32, filter_size=7,
                 hidden_dim=100, num_classes=10, weight_scale=1e-3, reg=0.0,
                 dtype=np.float32):
        """
        Инициализация новой сети.

        Входы:
         - input_dim: кортеж (C, H, W), задающий размер входных данных
         - num_filters: количество фильтров, используемых в сверточном слое
         - filter_size: ширина / высота фильтров для использования в сверточном слое
         - hidden_dim: количество нейронов, которые будут использоваться в полносвязном скрытом слое
         - num_classes: количество классов для окончательного аффинного слоя.
         - weight_scale: стандартное отклонение для случайной инициализации
           весов.
         - reg:  коэфициент L2 силы регуляризации
         - dtype: numpy datatype для использования в вычислениях.
        """
        self.params = {}
        self.reg = reg
        self.dtype = dtype

        ############################################################################
        # ЗАДАНИЕ: Инициализация весов и смещений для 3-х слойной сверточной сети. #
        # Веса должны инициализироваться гауссовым распределением с центром в 0,0  #
        # и со стандартным отклонением, равным weight_scale; смещения должны       #
        # инициализироваться нулем. Все веса и смещения должны храниться в         #
        # словаре self.params. Храните веса и смещения для сверточного             #
        # слоя, используя ключи «W1» и «b1»; используйте ключи «W2» и «b2» для     #
        # весов и смещений скрытого аффинного слоя, а также ключи «W3» и «b3»      #
        # для весов и смещений выходного аффинного слоя.                           #
        #                                                                          #
        # ВАЖНО: для этого задания можно допустить, что дополнение нулями          #
        # и stride первого сверточного слоя выбраны так, что                       #
        # **ширина и высота входных данных сохраняются**. Просмотрите              #
        # начало функции loss (), чтобы увидеть, как это происходит.               #
        ############################################################################
        
        pass
        ############################################################################
        #                             КОНЕЦ ВАШЕГО КОДА                            #
        ############################################################################

        for k, v in self.params.items():
            self.params[k] = v.astype(dtype)


    def loss(self, X, y=None):
        """
        Оценивает потери и градиент для трехслойной сверточной сети.

        Вход / выход: тот же API, что и TwoLayerNet, в файле fc_net.py.
        """
        W1, b1 = self.params['W1'], self.params['b1']
        W2, b2 = self.params['W2'], self.params['b2']
        W3, b3 = self.params['W3'], self.params['b3']

        # Передаваемый conv_param в прямом направлении для сверточного слоя
        # Дополнение нулями и шаг, выбраны такими, чтобы сохранить входные пространственного размера
        filter_size = W1.shape[2]
        conv_param = {'stride': 1, 'pad': (filter_size - 1) // 2}

        # Передаваемый pool_param в прямом наравлении для слоя с макс пулом
        pool_param = {'pool_height': 2, 'pool_width': 2, 'stride': 2}

        scores = None
        ############################################################################
        # ЗАДАНИЕ:выполнить прямое распротсранение для трехслойной сверточной сети,#
        # вычислить рейтинги классов для примеров из X и сохранить их в переменной
        # scores                                                                   #
        #                                                                          #
        # Вы можете использовать функции, определенные в dlcv / fast_layers.py и   #
        # dlcv / layer_utils.py  (уже импортирован).                               #
        ############################################################################
        
        pass
        ############################################################################
        #                             КОНЕЦ ВАШЕГО КОДА                            #
        ############################################################################

        if y is None:
            return scores

        loss, grads = 0, {}
        ############################################################################
        # ЗАДАНИЕ: выполнить обратное распротстранение для 3-х слойной сверточной  #
        # сети,сохранить потери и градиенты в переменных loss и grads. Вычислить   #
        # потери с помощью softmax и убедиться, что grads[k] содержит градиенты    #
        # для self.params[k]. Не забудьте добавить регуляризацию L2!               #
        #                                                                          #
        # ПРИМЕЧАНИЕ. Чтобы пройти автоматические тесты убедитесь,                 #
        # что регуляризация L2 включает в себя фактор 0,5 для упрощения            #
        # выражения для градиента.                                                 #
        ############################################################################
        
        pass
        ############################################################################
        #                             END OF YOUR CODE                             #
        ############################################################################

        return loss, grads
