:- discontiguous    % информирует интерпретатор что
proc/1.             % процедуры proc(n) не идут подряд      

:- dynamic  % информирует интерпретатор о том, что определения предикатов
            % могут изменяться в ходе выполнения программы
товар/4.    % формат: <имя предиката>/<кол-во аргументов>

% адрес рабочего файла
workspace('C:/Users/kosta/Documents/Учёба/7 семестр/МиСИИ/ЛР 5/db_product.dat').

% первоначальная вид базы данных при запуске программы
%     N   Товар      Магазин  Цена
товар(1, молоко,     казачок, 108  ).
товар(2, молоко,     милка,   87   ).
товар(3, кефир,      казачок, 130  ).
товар(4, сметана,    казачок, 91   ).
товар(5, мороженное, милка,   84   ).
товар(6, творог,     милка,   98   ).
%-------------------------------------------------------------------------------------------------------

start :- menu.  % предикат для запуска программы

% ====================== МЕНЮ ======================
menu :-
    repeat, nl,

    write('******************************************'), nl,
    %write('* 1. Добавление записи в БД              *'), nl,
    %write('* 2. Удаление записи из БД               *'), nl,
    write('* 3. Просмотр БД                         *'), nl,
    write('* 4. Загрузка БД из файла                *'), nl,
    write('* 5. Сохранение БД в файле               *'), nl,
    %write('* 6. Реляционные операции                *'), nl,

    write('******************************************'), nl,
    write('* 7. Корректировка по названию магазина  *'), nl,
    write('* 8. Вывод товаров магазина *'), nl,

    write('******************************************'), nl,
    write('* 9. Выход                               *'), nl,
    write('******************************************'), nl, nl,

    write('Введите номер процедуры (с точкой в конце!):'), nl,
    read(C), nl,    % Ввод номера процедуры
    proc(C),        % Запуск процедуры с номером С
    C=9, ! .        % Если C=9 завершить программу
%-------------------------------------------------------------------------------------------------------

% ожидание ввода литеры
waitExit :-
    write('...нажмите любую клавишу, чтобы продолжить...'), nl,
    get0(_), get0(_).


% ============= 1. ДОБАВЛЕНИЕ ЗАПИСИ ИЗ БД =============
/*proc(1) :-
    write('Введите номер:'), nl, read(N),
    write('Введите ФИО (в кавычках): '), nl, read(ФИО),
    write('Введите номер группы: '), nl, read(Группа),
    write('Введите оценки в формате [Оценка1, Оценка2, Оценка3]): '), nl, read(Оценки), nl,

    assertz(студент(N, ФИО, Группа, Оценки)),   % добавление факта в БД
    write('Студент '), display(ФИО), write(' был добавлен в БД'), nl, nl,
    waitExit.*/
%-------------------------------------------------------------------------------------------------------


% ============= 2. УДАЛЕНИЕ ЗАПИСИ ИЗ БД =============
/*proc(2) :-
    write('Введите номер студента для удаления: '), nl,
    read(N), nl,    % ввод номера сотрудника

    retract(студент(N, _, _, _)),   % удаление записи о студенте

    % запись удалось найти удалить
    write('Студент '), display(N), write(' был успешно удален из БД'), nl, nl,
    waitExit,

    ! ; % завершение или альтернатва

    % запись не найдена - удалить нечего
    write('Такого студента в базе данных нет'), nl, nl,
    waitExit.*/
%-------------------------------------------------------------------------------------------------------


% ================== 3. ПРОСМОТР БД ==================
proc(3) :-
    % извлекаем и выводим записи из БД пока они не закончатся
    товар(N, X1, X2, X3), 
    showProduct(товар(N, X1, X2, X3)),

    fail ;      % если запись нашлась - искусственно вернись (false) и поищи ещё
                % иначе конец просмотра

    waitExit.   % завершение - записей больше нет

% выводим данные студента
showProduct(товар(N, Поле1, Поле2, Поле3)) :-
    write('Номер: '), display(N), nl,
    write('Товар: '), display(Поле1), nl,
    write('Магазин: '), display(Поле2), nl,
    write('Цена, руб.: '), write(Поле3), nl, nl.
%-------------------------------------------------------------------------------------------------------


% ============== 4. ЗАГРУЗКА В БД ИЗ ФАЙЛА ==============
proc(4) :-
    workspace(File),
    see(File),                          % входной поток
    retractall(студент(_, _, _, _)),    % предварительная очистка БД
    db_load,                            % заполнение БД термами из файла
    seen,                               % закрытие потока
    write('БД успешно загружена'), nl, nl,
    waitExit.

% загрузка термов в БД из открытого файла
db_load :-
    read(Term),             % чтение терма
    (Term == end_of_file, ! % если файл кончился - завершение
     ; assertz(Term),       % иначе добавить терм в конец БД
     db_load                % рекурсивно читаем след. терм
    ).
%-------------------------------------------------------------------------------------------------------


% ============== 5. СОХРАНЕНИЕ БД В ФАЙЛЕ ==============
proc(5) :-
    workspace(File), 
    tell(File),                     % выходной поток
    save_db(студент(_, _, _, _)),   % сохранение термов
    told,                           % закрытие потока
    write('БД сохранена в файле db_student.dat'), nl, nl,
    waitExit.

% сохранение термов в открытом файле
save_db(Term) :-
    Term,                           % берём терм (запись БД)
    writeq(Term), write('.'), nl,   % переносим терм в файл вместе с точкой
    fail ;                          % ищем термы, пока они не закончатся
    true.                           % конец
%-------------------------------------------------------------------------------------------------------


% ============== 6. ОПЕРАЦИИ РЕЛЯЦИОННОЙ АЛГЕБРЫ ==============
/*proc(6) :-
    подмножество_студентов('ИС2', R1),  % R1 - список студентов группы ИС2
    write('Отношение R1: студенты из группы ИС2'), nl,
    вывод_списка(R1), nl, 
    список_в_бд(R1),                    % перенос элементов R1 в БД

    подмножество_отличников(R2),        % R2 - список студентов-отличников
    write('Отношение R2: студенты-отличники'), nl,
    вывод_списка(R2), nl,
    список_в_бд(R2),                    % перенос элементов R2 в БД

    write('1) Объединение (R1 ИЛИ R2): '), nl,
    объединение(R_Union),               % R1_2 - студенты групп ИС2 или ПИ1
    вывод_списка(R_Union), nl,

    write('2) Пересечение (R1 И R2): '), nl,
    пересечение(R_Intersect),           % R1_2 - студенты групп и ИС2, и ПИ1
    вывод_списка(R_Intersect), nl,

    write('3) Разность (R1 И НЕ R2): '), nl,
    разность(R_Except),                 % R1_2 - студенты группы ИС2, и не ПИ1
    вывод_списка(R_Except), nl,

    retractall(студент_R(_, _, _, _)),  % очистка БД от временных объектов
    waitExit.*/
%-------------------------------------------------------------------------------------------------------
% ОБЪЕДИНЕНИЕ отношений - R1 ИЛИ R2
/*объединение_R1_R2(N, ФИО, Группа, Оценки) :-
    студент_R(N, ФИО, Группа, Оценки), Группа = 'ИС2' ;
    студент_R(N, ФИО, Группа, Оценки), средний_балл(Оценки, Средний), Средний > 4, Группа \= 'ИС2'.

% R1_2 - подмножество студентов R1 ИЛИ R2
объединение(R_Union) :-
    bagof(студент_R1_2(N, ФИО, Группа, Оценки),
          объединение_R1_R2(N, ФИО, Группа, Оценки), R_Union).*/
%-------------------------------------------------------------------------------------------------------
% ПЕРЕСЕЧЕНИЕ отношений - R1 И R2
/*пересечение_R1_R2(N, ФИО, Группа, Оценки) :-
    студент_R(N, ФИО, Группа, Оценки), Группа='ИС2',
    средний_балл(Оценки, Средний), Средний > 4.

% R1_2 - подмножество студентов R1 И R2
пересечение(R_Intersect) :-
    bagof(студент_R1_2(N, ФИО, Группа, Оценки),
          пересечение_R1_R2(N, ФИО, Группа, Оценки), R_Intersect).*/
%-------------------------------------------------------------------------------------------------------
% РАЗНОСТЬ отношений - R1 И НЕ R2
/*разность_R1_R2(N, ФИО, Группа, Оценки) :-
    студент_R(N, ФИО, Группа, Оценки), Группа='ИС2',
    \+ (студент_R(N, ФИО, Группа, Оценки), средний_балл(Оценки, Средний), Средний > 4).

% R1_2 - подмножество студентов R1 И НЕ R2
разность(R_Except) :-
    bagof(студент_R1_2(N, ФИО, Группа, Оценки),
          разность_R1_R2(N, ФИО, Группа, Оценки), R_Except).*/
%-------------------------------------------------------------------------------------------------------
% R - подмножество студентов, принадлежащих указанной группе
/*подмножество_студентов(НомерГруппы, R) :-
    bagof(студент(N, ФИО, НомерГруппы, Оценки),
          студент(N, ФИО, НомерГруппы, Оценки), R).

% Отличники - подмножество студентов со средним баллом > 4.0
подмножество_отличников(Отличники) :-
    findall(студент(N, ФИО, Группа, Оценки),
            (студент(N, ФИО, Группа, Оценки), средний_балл(Оценки, Средний), Средний > 4.0),
            Отличники).

% перенос списка R в объекты БД
список_в_бд([H|T]) :-
    H = студент(N, ФИО, Группа, Оценки),
    
    (
        retract(студент_R(N, ФИО, Группа, Оценки)), % если терм уже есть в БД - не создавать копию
        assertz(студент_R(N, ФИО, Группа, Оценки)), 
        !; 
        assertz(студент_R(N, ФИО, Группа, Оценки))  % иначе просто добавить новый
    ), 
    
    список_в_бд(T).
список_в_бд([]).

% вывод элементов списка построчно
вывод_списка([H|T]) :-
    write(H), nl,
    вывод_списка(T).
вывод_списка([]).*/
%-------------------------------------------------------------------------------------------------------


% ============ 7. Корректировка по названию магазина ============
proc(7) :-
    write('Введите название магазина:'), nl,
    read(ShopName), nl,

    write('Введите название товара:'), nl,
    read(Product), nl,

    товар(N, Product, ShopName, Цена),

    write('Введите новую цену:'), nl,
    read(НоваяЦена), nl,

    retract(товар(N, Product, ShopName, Цена)),       % удалить старую запись
    assertz(товар(N, Product, ShopName, НоваяЦена)),  % добавить обновлённую

    write('Успех!'), nl, nl,
    waitExit, !
    
    ; write('Запись не найдена.'), nl, nl, 
    waitExit.
    
%-------------------------------------------------------------------------------------------------------


% ============ 8. Вывод товаров магазина ============
proc(8) :-
    write('Введите название магазина:'), nl,
    read(ShopName), nl,

    подмножество_магазина(ТоварыМагазина, ShopName),
    (   ТоварыМагазина = [],                                     
        write('такой магазин не найден.'), 
        nl, nl, ! 
    ;                                                      
        write('Список товаров:'), nl,                       
        вывод_товаров(ТоварыМагазина)
    ),

    waitExit.

% поиск всех товаров указанного магазина
подмножество_магазина(ТоварыМагазина, ShopName) :-
    findall(товар(N, X1, X2, X3),
            (товар(N, X1, X2, X3), X2 = ShopName),
            ТоварыМагазина).

% вывод списка товаров
вывод_товаров([]).
вывод_товаров([H|T]) :-
    showProduct(H),
    вывод_товаров(T).
%-------------------------------------------------------------------------------------------------------


% ========================= 9. Выход =========================
proc(9) :-
    write('До свидания.'), nl.